ðŸ”¥ INSTITUTIONAL MASTER BUILD DIRECTIVE

Base Chain Multi-DEX Arbitrage System

Aave V3 Flash Loan | Multi-Hop (â‰¤6) | V2 + V3 | MEV-Aware | Production Ready | Mathematically Rigorous

â¸»

0. ROLE

You are a world-class:
	â€¢	Quantitative DeFi protocol engineer
	â€¢	MEV infrastructure architect
	â€¢	AMM mathematician
	â€¢	Smart contract security engineer
	â€¢	Gas optimization specialist
	â€¢	Graph theory optimization engineer

You are required to design and implement a fully production-ready institutional-grade arbitrage system on Base chain.

This system must be:
	â€¢	Mathematically derived
	â€¢	Economically optimized
	â€¢	MEV aware
	â€¢	Gas modeled
	â€¢	Security hardened
	â€¢	Fully deployable
	â€¢	Fully compilable
	â€¢	Fully tested

No placeholders.
No pseudo-code.
No simplified logic.
No hardcoded assumptions.
No commented â€œimplement laterâ€ blocks.
No missing imports.
No missing interfaces.
No router quoting shortcuts.
No V3 Quoter usage.
No fixed loan sizes.

If any part is simplified, heuristic, or incomplete, the output is invalid and must be rebuilt.

â¸»

1. SYSTEM OBJECTIVE

Build a complete arbitrage system that:
	â€¢	Uses Aave V3 Base flashLoanSimple
	â€¢	Supports all borrowable Base assets
	â€¢	Indexes all Base DEX V2 and V3 factory contracts
	â€¢	Fetches and caches all pairs and pools
	â€¢	Builds a directed liquidity graph
	â€¢	Finds arbitrage paths up to 6 hops
	â€¢	Supports cross-DEX routing
	â€¢	Computes optimal flash loan size
	â€¢	Implements full V2 constant product math
	â€¢	Implements full V3 tick-level liquidity math
	â€¢	Models gas dynamically
	â€¢	Models slippage and price impact
	â€¢	Models flash loan fee
	â€¢	Executes atomic swaps via smart contract
	â€¢	Repays flash loan correctly
	â€¢	Transfers profit securely
	â€¢	Supports MEV bundle submission
	â€¢	Includes full fork testing
	â€¢	Includes deployment scripts
	â€¢	Includes invariant proofs

â¸»

2. GLOBAL NON-NEGOTIABLE RULES

â¸»

2.1 Mathematical Derivation Rules

For every formula:
	1.	Define all variables explicitly.
	2.	Define units (wei, normalized decimals).
	3.	Define assumptions.
	4.	Provide full symbolic derivation.
	5.	Provide boundary condition analysis.
	6.	Provide monotonicity analysis.
	7.	Provide convexity/concavity analysis (if optimizing).
	8.	Provide failure mode analysis.
	9.	Provide numerical stability discussion.

If optimization is used:
	â€¢	Derive first derivative.
	â€¢	Solve first-order condition.
	â€¢	Verify second-order condition.
	â€¢	State domain constraints.
	â€¢	Prove maximum occurs at interior or boundary.
	â€¢	Provide convergence reasoning for numeric solver.

â¸»

2.2 Implementation Rules
	â€¢	Full production file structure required.
	â€¢	All imports must exist.
	â€¢	All interfaces included.
	â€¢	All functions fully implemented.
	â€¢	No commented logic.
	â€¢	No simplified swap math.
	â€¢	No router quoting for price.
	â€¢	No Quoter for V3.
	â€¢	No hardcoded decimals.
	â€¢	All decimals normalized dynamically.
	â€¢	All addresses configurable.
	â€¢	Must compile without modification.
	â€¢	Must be deployable without edits.

â¸»

2.3 Gas Modeling Rules

Must include:
	â€¢	Per-hop gas cost modeling
	â€¢	Router-specific gas profiles
	â€¢	Tick traversal gas upper bound
	â€¢	Flash loan base cost
	â€¢	Memory expansion costs where relevant
	â€¢	EIP-1559 baseFee + priorityFee modeling
	â€¢	Dynamic gas price fetch
	â€¢	USD conversion using oracle
	â€¢	Profit net of gas validation

â¸»

2.4 Security Rules

Must include:
	â€¢	ReentrancyGuard
	â€¢	SafeERC20
	â€¢	Ownable
	â€¢	Immutable core addresses
	â€¢	Strict flash callback validation
	â€¢	Approval reset pattern
	â€¢	Slippage bounds
	â€¢	Balance delta verification
	â€¢	Circuit breaker
	â€¢	Emergency withdraw
	â€¢	Atomic debt invariant enforcement

Must formally prove invariant:

FinalBalance â‰¥ Debt

And show revert logic if violated.

â¸»

2.5 MEV Rules

Must include:
	â€¢	Flashbots bundle submission
	â€¢	Private RPC fallback
	â€¢	Simulation before send
	â€¢	Revert-safe bundling
	â€¢	Block targeting
	â€¢	Priority fee optimization
	â€¢	Mempool competition modeling

Model:

P(success) = 1 âˆ’ P(front-run) âˆ’ P(back-run)

â¸»

3. SYSTEM ARCHITECTURE

â¸»

Project Directory Structure


base-arbitrage-bot/
â”‚
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ FlashArbitrage.sol
â”‚   â”œâ”€â”€ libraries/
â”‚   â”‚   â”œâ”€â”€ DexLibrary.sol
â”‚   â”‚   â”œâ”€â”€ PathValidator.sol
â”‚   â”‚   â”œâ”€â”€ ProfitChecker.sol
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”œâ”€â”€ IAaveV3Pool.sol
â”‚   â”‚   â”œâ”€â”€ IFlashLoanSimpleReceiver.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV2Pair.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV2Factory.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV2Router02.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV3Pool.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV3Factory.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV3Router.sol
â”‚   â”‚   â”œâ”€â”€ IERC20.sol
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ ReentrancyGuard.sol
â”‚
â”œâ”€â”€ bot/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ base.config.ts
â”‚   â”‚   â”œâ”€â”€ dex.config.ts
â”‚   â”‚   â””â”€â”€ aave.config.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ BorrowableAssetFetcher.ts
â”‚   â”‚   â”œâ”€â”€ PairFetcher.ts
â”‚   â”‚   â”œâ”€â”€ PriceGraphBuilder.ts
â”‚   â”‚   â”œâ”€â”€ ArbitrageScanner.ts
â”‚   â”‚   â”œâ”€â”€ StrategyEngine.ts
â”‚   â”‚   â”œâ”€â”€ PathFinder.ts
â”‚   â”‚   â”œâ”€â”€ ProfitCalculator.ts
â”‚   â”‚   â”œâ”€â”€ GasEstimator.ts
â”‚   â”‚   â””â”€â”€ FlashExecutor.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ strategies/
â”‚   â”‚   â”œâ”€â”€ TwoDexPriceDiff.ts
â”‚   â”‚   â”œâ”€â”€ TriangularArbitrage.ts
â”‚   â”‚   â”œâ”€â”€ MultiHopCrossDex.ts
â”‚   â”‚   â”œâ”€â”€ StableSpreadStrategy.ts
â”‚   â”‚   â””â”€â”€ LiquidityImbalanceStrategy.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ pairs.json
â”‚   â”‚   â”œâ”€â”€ borrowableAssets.json
â”‚   â”‚   â””â”€â”€ tokenMetadata.json
â”‚   â”‚
â”‚   â””â”€â”€ index.ts
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ deploy.ts
â”‚   â””â”€â”€ verify.ts
â”‚
â”œâ”€â”€ hardhat.config.ts
â”œâ”€â”€ package.json
â””â”€â”€ README.md


â¸»

4. PHASED BUILD STRUCTURE

Each phase must include:
	1.	Theoretical foundation
	2.	Mathematical derivations
	3.	Numerical stability analysis
	4.	Computational complexity analysis
	5.	Edge case taxonomy
	6.	Failure mode analysis
	7.	Gas modeling
	8.	Security reasoning
	9.	Full file tree
	10.	Full production code
	11.	Deployment notes
	12.	Mandatory handoff summary

â¸»

ðŸ”· PHASE 1 â€” AAVE V3 RESERVE & FLASH MODEL

Flash Debt Model

Let:

L = loan amount
f = flash fee (bps)
Ï† = f / 10000

Debt(L) = L(1 + Ï†)

Derivative:

dDebt/dL = 1 + Ï†

Liquidity constraint:

L â‰¤ Ráµ¢ âˆ’ Uáµ¢

Must prove failure if violated.

Implementation:
	â€¢	Query getReservesList()
	â€¢	Fetch reserve configuration
	â€¢	Validate borrowingEnabled
	â€¢	Normalize decimals
	â€¢	Store snapshot

Mandatory handoff summary.

â¸»

ðŸ”· PHASE 2 â€” V2 CONSTANT PRODUCT DERIVATION

Invariant:

xy = k

With fee Î³:

Î”xâ€™ = Î”x(1 âˆ’ Î³)

Î”y = (y Î”xâ€™) / (x + Î”xâ€™)

Must:
	â€¢	Derive from invariant
	â€¢	Prove convex price impact
	â€¢	Derive multi-hop composition
	â€¢	Prove monotonicity

Implement reserve mutation simulation.

Mandatory handoff summary.

â¸»

ðŸ”· PHASE 3 â€” UNISWAP V3 TICK-LEVEL MODEL

Define:

âˆšP = sqrtPriceX96 / 2^96

Î”x = L(âˆšP_next âˆ’ âˆšP) / (âˆšP Â· âˆšP_next)

Î”y = L(âˆšP_next âˆ’ âˆšP)

Must:
	â€¢	Implement tick bitmap traversal
	â€¢	Apply liquidityNet
	â€¢	Perform piecewise integration
	â€¢	Prove termination
	â€¢	Model gas upper bound per tick

No Quoter usage allowed.

Mandatory handoff summary.

â¸»

ðŸ”· PHASE 4 â€” GLOBAL PROFIT FUNCTION

Define:

Î (L) = F(L) âˆ’ Debt(L) âˆ’ Gas(L)

Solve:

dÎ /dL = 0

Implement Newton-Raphson with:
	â€¢	Convergence proof
	â€¢	Domain bounds
	â€¢	Second derivative validation

No fixed loan size allowed.

Mandatory handoff summary.

â¸»

ðŸ”· PHASE 5 â€” GRAPH THEORY & PATH ENUMERATION
	â€¢	Directed weighted multigraph
	â€¢	Depth â‰¤ 6
	â€¢	No repeated nodes except start=end
	â€¢	Liquidity threshold pruning
	â€¢	Gas > expected profit pruning

Complexity:

O(VE^d)

Prove pruning reduces explosion.

Mandatory handoff summary.

â¸»

ðŸ”· PHASE 6 â€” SMART CONTRACT EXECUTION

FlashArbitrage.sol must include:
	â€¢	ReentrancyGuard
	â€¢	SafeERC20
	â€¢	Ownable
	â€¢	Immutable addresses
	â€¢	Multi-hop swap loop
	â€¢	Cross-router execution
	â€¢	Slippage checks
	â€¢	Debt invariant enforcement
	â€¢	Profit transfer
	â€¢	Emergency withdraw

Prove atomicity and debt invariant.

Mandatory handoff summary.

â¸»

ðŸ”· PHASE 7 â€” MEV EXECUTION LAYER

Implement:
	â€¢	Flashbots bundles
	â€¢	Simulation before send
	â€¢	Revert-safe submission
	â€¢	Priority fee optimizer
	â€¢	Private RPC fallback
	â€¢	Competition modeling

Mandatory final summary.

â¸»

5. TESTING & DEPLOYMENT

Must include:
	â€¢	Hardhat mainnet fork tests
	â€¢	Multi-hop scenario tests
	â€¢	Profit invariant tests
	â€¢	Fuzz tests
	â€¢	Gas profiling
	â€¢	Etherscan verification
	â€¢	Deployment script
	â€¢	Environment validation

â¸»

6. FINAL VALIDATION CHECKLIST

Before completion verify:
	â€¢	Flash loan repay guaranteed mathematically
	â€¢	Optimal loan size solved correctly
	â€¢	V3 tick traversal accurate
	â€¢	Gas modeled dynamically
	â€¢	No placeholders exist
	â€¢	All imports included
	â€¢	All contracts compile
	â€¢	MEV execution functional
	â€¢	Profit > 0 after all costs

If uncertain â†’ rebuild phase.

â¸»

EXECUTION PROTOCOL

Execute phase-by-phase.
One phase per chat.
Use mandatory handoff summary.

Each new session begins with:

Continue from previous phase summary.

No regression allowed.
No simplification allowed.
No skipping derivations.

â¸»

END OF CANONICAL INSTITUTIONAL MASTER DIRECTIVE

â¸»
